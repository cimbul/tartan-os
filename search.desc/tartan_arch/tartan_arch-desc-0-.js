searchState.loadedDescShard("tartan_arch", 0, "Architecture-specific primitives for Tartan OS\nArchitecture-specific primitives for 64-bit Arm.\nDefine an exception vector table that forwards all …\nArchitecture-specific primitives for 32-bit Arm.\nDefine an exception vector table that forwards all …\nUnconditionally transfer control to the instruction at the …\nArchitecture-specific primitives for 32-bit x86 processors.\nArchitecture-specific primitives for 64-bit x86 processors.\nArchitecture-specific primitives common to 32-bit and …\n<code>H</code> (handler) mode: use the stack pointer register for the …\n<code>EL</code>: Defines the privilege level of executing code. Higher …\n<code>T</code> (thread) mode: use the stack pointer register from EL0.\n<code>EL1</code>, used for OS kernel code.\nControls which stack pointer register is used when …\n<code>EL3</code>, used for the secure manager.\n<code>EL2</code>, used for hypervisors in virtualized systems.\n<code>EL0</code>, used for unprivileged user code.\nFloating-point control and status.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the current exception level. Only accessible from EL1 …\nGet the value of the flag for the current exception level. …\nException and interrupt handling.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUpdate the value of the flag for the current exception …\n<code>FPCR</code>: Influences floating-point instruction execution.\nStatus/mask bits for each type of floating-point exception.\nRound toward negative infinity.\nRound to the nearest number, with ties toward even numbers.\nRound toward positive infinity.\nFloating-point rounding mode, as defined by IEEE 754.\n<code>FPSR</code>: Indicates non-trapped floating-point exceptions.\nRound toward zero (truncate).\n<code>AHP</code>: Use an alternative format for half-precision floats …\n<code>DN</code>: Always use the default encoding for NaN results. …\nIndicates any non-trapped exceptions that have been …\n<code>FZ</code>: When a result would be denormal, yield zero instead. …\n<code>FZ16</code>: Counterpart to <code>flush_to_zero</code> for half-precision …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRetrieve the current value of this register\nRetrieve the current value of this register\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe name of the enum variant in code, if one is defined …\n<code>RMode</code>: The IEEE 754 rounding mode in use.\nUpdate the register to the given value.\nUpdate the register to the given value.\n<code>AHP</code>: Use an alternative format for half-precision floats …\n<code>DN</code>: Always use the default encoding for NaN results. …\nIndicates any non-trapped exceptions that have been …\n<code>FZ</code>: When a result would be denormal, yield zero instead. …\n<code>FZ16</code>: Counterpart to <code>flush_to_zero</code> for half-precision …\n<code>RMode</code>: The IEEE 754 rounding mode in use.\nFor each type of floating-point exception, defines whether …\nFor each type of floating-point exception, defines whether …\n<code>AHP</code>: Use an alternative format for half-precision floats …\n<code>DN</code>: Always use the default encoding for NaN results. …\nIndicates any non-trapped exceptions that have been …\n<code>FZ</code>: When a result would be denormal, yield zero instead. …\n<code>FZ16</code>: Counterpart to <code>flush_to_zero</code> for half-precision …\n<code>RMode</code>: The IEEE 754 rounding mode in use.\nFor each type of floating-point exception, defines whether …\nBreakpoint triggered at current exception level.\nBreakpoint triggered at lower exception level.\nExecuted a <code>BRK</code> breakpoint instruction.\nClassifies different exception causes.\nException from current level using current-level SP …\nException from current level using SP_EL0 (thread mode)\nData abort triggered at current exception level.\nData abort triggered at lower exception level.\nTrapped access to a FPU/vector register or instruction.\nAn external interrupt through the higher-priority fast …\nTrapped floating point exception.\nTried to execute instructions after an illegal return.\nInstruction abort triggered at current exception level.\nInstruction abort triggered at lower exception level.\nAn external interrupt (IRQ).\nThe kind of exception being handled: sync, IRQ, FIQ, …\nException from lower level (e.g., EL0) in 64-bit mode\nException from lower level (e.g., EL0) in 32-bit mode\n<code>DAIF</code>: Controls masking of different kinds of exceptions.\nProgram counter not properly aligned.\nImproperly authenticated pointer detected. Requires …\nStack pointer not properly aligned.\nThe exception level that generated an exception.\nSoftware step at current exception level.\nSoftware step at lower exception level.\nTriggered a system call via the <code>SVC</code> instruction.\nA standard exception traceable to a specific instruction.\n<code>ESR_ELx</code>: Holds information about the cause of the …\nAn internal error with the processor (SError).\nSystem error (SError).\nTrapped access to a system register or instruction.\nTried to execute an undefined/unsupported opcode, or for …\nTrapped access to a vector register or instruction.\n<code>VBAR_ELx</code>: Contains the address of the <code>VectorTable</code> that the …\nA single entry in the exception <code>VectorTable</code>.\nException vector table that contains code to handle …\nTrapped execution of a wait instruction (<code>WFE</code>/<code>WFI</code>).\nWatchpoint triggered at current exception level.\nWatchpoint triggered at lower exception level.\n<code>EC</code>: The class of exception that was triggered.\n<code>ISS</code>: Additional data about the exception in a format that …\n<code>D</code>: Mask debugging-related exceptions (breakpoints, …\n<code>F</code>: Mask fast (FIQ) interrupts.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRetrieve the current value of this register for the …\nRetrieve the current value of this register\nRetrieve the current value of this register for the …\n<code>I</code>: Mask regular (IRQ) interrupts.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>IL</code>: When set, indicates that the instruction that …\nThe name of the enum variant in code, if one is defined …\nUpdate the register for the specified exception level with …\nUpdate the register to the given value.\nUpdate the register for the specified exception level with …\n<code>EC</code>: The class of exception that was triggered.\n<code>ISS</code>: Additional data about the exception in a format that …\n<code>D</code>: Mask debugging-related exceptions (breakpoints, …\n<code>F</code>: Mask fast (FIQ) interrupts.\n<code>I</code>: Mask regular (IRQ) interrupts.\n<code>IL</code>: When set, indicates that the instruction that …\n<code>A</code>: Mask system error (SError) exceptions.\n<code>A</code>: Mask system error (SError) exceptions.\n<code>EC</code>: The class of exception that was triggered.\n<code>ISS</code>: Additional data about the exception in a format that …\n<code>D</code>: Mask debugging-related exceptions (breakpoints, …\n<code>F</code>: Mask fast (FIQ) interrupts.\n<code>I</code>: Mask regular (IRQ) interrupts.\n<code>IL</code>: When set, indicates that the instruction that …\n<code>A</code>: Mask system error (SError) exceptions.\nException and interrupt handling.\nThe kind of exception being handled\nContains the address of the <code>VectorTable</code> that the processor …\nException vector table that contains code to handle each …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRetrieve the current value of this register for the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUpdate the register for the specified exception level with …\nSupport for protected mode operation.\nA task state segment (TSS) with fixed redirect and I/O …\nStack pointer and segment for a given privilege level\nI/O permission map and interrupt redirect map, which are …\nSaved task state that makes up the most significant part …\n<code>EBP</code> value saved by the processor.\nI/O permission map and interrupt redirect map\n<code>CS</code> value saved by the processor.\nPage table pointer from <code>ControlRegister3</code>.\n<code>DS</code> value saved by the processor.\nIndicates that a debug exception should be raised when …\n<code>EDI</code> value saved by the processor.\n<code>EFLAGS</code> value saved by the processor.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>EAX</code> value saved by the processor.\n<code>EBX</code> value saved by the processor.\n<code>ECX</code> value saved by the processor.\n<code>EDX</code> value saved by the processor.\n<code>ES</code> value saved by the processor.\n<code>FS</code> value saved by the processor.\n<code>GS</code> value saved by the processor.\nSaved task data and pointer to bitmaps\n<code>EIP</code> value saved by the processor.\nIndicates which handler to use for software-triggered …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe <code>IOPermissionBitmap</code> for this task.\nOffset from the start of this structure to start of the …\n<code>LocalDescriptorTableRegister</code> value to load when executing …\nCreate a new zero-initialized header\nCreate a new zero-initialized stack pointer\nStack pointer (<code>SP</code>) value for this privilege level.\nSegment selector saved by the processor referencing the …\nStack pointer and segment for privilege levels 0–2.\nStack segment (<code>SS</code>) value for this privilege level.\nPointer to the shadow stack.\n<code>ESI</code> value saved by the processor.\n<code>SP</code> value saved by the processor for privilege level 3.\n<code>SS</code> value saved by the processor for privilege level 3.\n<code>CR8</code>: System control register for controlling interrupts …\n<code>IA32_EFER</code>: Model-specific register that controls features …\nReturns the argument unchanged.\nReturns the argument unchanged.\nRetrieve the current value of this register\nRetrieve the current value of this register\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>IA32_EFER.LMA</code>: Indicates 64-bit mode is active. Read-only.\n<code>IA32_EFER.LME</code>: Support 64-bit mode.\n<code>IA32-EFER.NXE</code>: Support no-execute (NX) bit in page tables.\nSupport for protected mode operation.\nUpdate the register to the given value.\nUpdate the register to the given value.\n<code>IA32_EFER.LMA</code>: Indicates 64-bit mode is active. Read-only.\n<code>IA32_EFER.LME</code>: Support 64-bit mode.\n<code>IA32-EFER.NXE</code>: Support no-execute (NX) bit in page tables.\n<code>IA32_EFER.SCE</code>: Support <code>SYSCALL</code>/<code>SYSRET</code> in 64-bit mode.\n<code>CR8.TPL</code>: Threshold for blocking low-priority interrupts. …\n<code>IA32_EFER.SCE</code>: Support <code>SYSCALL</code>/<code>SYSRET</code> in 64-bit mode.\n<code>CR8.TPL</code>: Threshold for blocking low-priority interrupts. …\n<code>IA32_EFER.LMA</code>: Indicates 64-bit mode is active. Read-only.\n<code>IA32_EFER.LME</code>: Support 64-bit mode.\n<code>IA32-EFER.NXE</code>: Support no-execute (NX) bit in page tables.\n<code>IA32_EFER.SCE</code>: Support <code>SYSCALL</code>/<code>SYSRET</code> in 64-bit mode.\n<code>CR8.TPL</code>: Threshold for blocking low-priority interrupts. …\nStack and I/O permission map pointers that make up the …\nReturns the argument unchanged.\nStack pointers available for use when handling interrupts. …\nCalls <code>U::from(self)</code>.\nOffset from the start of this structure to start of the …\nCreate a header with zero-initialized stack pointers and an\nStack pointers to use when switching to privilege levels …\n<code>CR0</code>: System control register with flags affecting …\n<code>CR4</code>: Miscellaneous system control flags.\n<code>XCR0</code>: System control flags that indicate OS support for …\n<code>EFLAGS</code>/<code>RFLAGS</code>: General flags, including control, status, …\n<code>CR0.AM</code>: Enables strict alignment checks for memory access, …\n<code>AC</code>: Enable strict alignment checks for memory accesses in …\n<code>AF</code>: Indicates a carry/borrow/overflow out of bit 3 in …\n<code>XCR0.AVX</code>: Manage 256-bit AVX state in upper halves of the …\n<code>XCR0.ZMM_Hi256</code>: Manage 512-bit AVX state in the upper …\n<code>XCR0.Hi16_ZMM</code>: Manage AVX-512 state in <code>ZMM16</code>–<code>ZMM31</code> with …\n<code>XCR0.OPMASK</code>: Manage AVX-512 opmask registers with <code>XSAVE</code>.\n<code>CR0.CD</code>: Disable all memory caching.\n<code>CR0.NW</code>: Disable write-back/write-through caching.\n<code>CF</code>: Indicates an arithmetic instruction generated a …\nDirectly clear the <code>task_switched_without_fpu_state</code> flag in …\n<code>CR4.CET</code> (<strong>Intel-only</strong>): Enable control-flow enforcement …\n<code>CR4.DE</code>: Enable newer debug register scheme where <code>DR4</code> and …\n<code>DF</code>: String instructions work on addresses high-to-low when …\n<code>CR4.FSGSBASE</code>: Enable instructions to load/store the <code>FS</code> and …\n<code>CR4.OSXSAVE</code>: Enable instructions for saving and restoring …\nProcessor feature detection with CPUID.\n<code>CR4.LA57</code>: Support 57-bit addresses using 5-level paging in …\n<code>XCR0.X87</code>: Hardcoded to 1.\n<code>CR0.EM</code>: Trigger an exception on all FPU instructions. Used …\n<code>CR0.ET</code>: On 386/486, 387 FPU instructions are supported if …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRetrieve the current value of the <code>EFLAGS</code> register.\nRetrieve the current value of this register\nRetrieve the current value of this register\nRetrieve the current value of this register\n<code>CR4.PGE</code>: Enable global pages, which are shared across task …\n<code>ID</code>: Indicates <code>CPUID</code> support when the flag is modifiable.\nSupport for managing interrupts.\n<code>IF</code>: Enable non-maskable interrupts. Non-maskable …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAccess to I/O space\n<code>IOPL</code>: Sets the privilege threshold for a task to access …\n<code>CR4.MCE</code>: Enable machine-check exception.\n<code>CR0.MP</code>: Enable exception behavior described for the <code>CR0.TS</code> …\n<code>XCR0.BNDCSR</code>: Manage MPX config and status registers with …\n<code>XCR0.BNDREG</code>: Manage MPX bounds registers with <code>XSAVE</code>.\n<code>CR0.NE</code>: Use internal error mechanism for FPU errors, …\n<code>NT</code>: Indicates that the processor should switch back to a …\n<code>CR4.PSE</code>: Support large pages (4MB). Applies to 32-bit mode …\nSupport for virtual memory paging.\n<code>CR0.PG</code>: Enable paging. Requires <code>protected_mode</code>.\n<code>PF</code>: Indicates that the least-significant byte of the …\n<code>CR4.PCE</code>: Allow access to performance monitoring counter in …\n<code>CR4.PAE</code>: Enable pages to map to physical addresses larger …\n<code>CR4.PCIDE</code>: Enable process-context identifiers (PCID) in …\nEnable protected mode. Does not enable paging on its own. …\n<code>CR4.PVI</code>: Enable virtual interrupts in protected mode.\nSupport for protected mode operation.\n<code>XCR0.PKRU</code>: Manage protection key rights registers with …\n<code>CR4.UMIP</code>: Prevent access to instructions that allow reads …\n<code>RF</code>: Disable instruction breakpoints.\n<code>CR4.SME</code> (<strong>Intel-only</strong>): Enable safer-mode extensions.\nUpdate the <code>EFLAGS</code> register with the given value, as …\nUpdate the register to the given value.\nUpdate the register to the given value.\nUpdate the register to the given value.\n<code>CR0.AM</code>: Enables strict alignment checks for memory access, …\n<code>AC</code>: Enable strict alignment checks for memory accesses in …\n<code>AF</code>: Indicates a carry/borrow/overflow out of bit 3 in …\n<code>XCR0.AVX</code>: Manage 256-bit AVX state in upper halves of the …\n<code>XCR0.ZMM_Hi256</code>: Manage 512-bit AVX state in the upper …\n<code>XCR0.Hi16_ZMM</code>: Manage AVX-512 state in <code>ZMM16</code>–<code>ZMM31</code> with …\n<code>XCR0.OPMASK</code>: Manage AVX-512 opmask registers with <code>XSAVE</code>.\n<code>CR0.CD</code>: Disable all memory caching.\n<code>CR0.NW</code>: Disable write-back/write-through caching.\n<code>CF</code>: Indicates an arithmetic instruction generated a …\n<code>CR4.CET</code> (<strong>Intel-only</strong>): Enable control-flow enforcement …\n<code>CR4.DE</code>: Enable newer debug register scheme where <code>DR4</code> and …\n<code>DF</code>: String instructions work on addresses high-to-low when …\n<code>CR4.FSGSBASE</code>: Enable instructions to load/store the <code>FS</code> and …\n<code>CR4.OSXSAVE</code>: Enable instructions for saving and restoring …\n<code>CR4.LA57</code>: Support 57-bit addresses using 5-level paging in …\n<code>XCR0.X87</code>: Hardcoded to 1.\n<code>CR0.EM</code>: Trigger an exception on all FPU instructions. Used …\n<code>CR0.ET</code>: On 386/486, 387 FPU instructions are supported if …\n<code>CR4.PGE</code>: Enable global pages, which are shared across task …\n<code>ID</code>: Indicates <code>CPUID</code> support when the flag is modifiable.\n<code>IF</code>: Enable non-maskable interrupts. Non-maskable …\n<code>IOPL</code>: Sets the privilege threshold for a task to access …\n<code>CR4.MCE</code>: Enable machine-check exception.\n<code>CR0.MP</code>: Enable exception behavior described for the <code>CR0.TS</code> …\n<code>XCR0.BNDCSR</code>: Manage MPX config and status registers with …\n<code>XCR0.BNDREG</code>: Manage MPX bounds registers with <code>XSAVE</code>.\n<code>CR0.NE</code>: Use internal error mechanism for FPU errors, …\n<code>NT</code>: Indicates that the processor should switch back to a …\n<code>CR4.PSE</code>: Support large pages (4MB). Applies to 32-bit mode …\n<code>CR0.PG</code>: Enable paging. Requires <code>protected_mode</code>.\n<code>PF</code>: Indicates that the least-significant byte of the …\n<code>CR4.PCE</code>: Allow access to performance monitoring counter in …\n<code>CR4.PAE</code>: Enable pages to map to physical addresses larger …\n<code>CR4.PCIDE</code>: Enable process-context identifiers (PCID) in …\nEnable protected mode. Does not enable paging on its own. …\n<code>CR4.PVI</code>: Enable virtual interrupts in protected mode.\n<code>XCR0.PKRU</code>: Manage protection key rights registers with …\n<code>CR4.UMIP</code>: Prevent access to instructions that allow reads …\n<code>RF</code>: Disable instruction breakpoints.\n<code>CR4.SME</code> (<strong>Intel-only</strong>): Enable safer-mode extensions.\n<code>SF</code>: Indicates that the most-significant bit of a result is …\n<code>OF</code>: Indicates that the result overflowed for signed …\n<code>CR4.OSXMMEXCPT</code>: Enable unmasked SIMD floating-point …\n<code>XCR0.SSE</code>: Manage SSE state with <code>XSAVE</code>, including the <code>XMM</code> …\n<code>CR4.OSFXSR</code>: Enable the <code>FXSAVE</code>/<code>FXRSTOR</code> and SSE …\n<code>CR4.SMAP</code>: Enable access prevention in privilege levels …\n<code>CR4.SMEP</code>: Enable execution prevention in privilege levels …\n<code>CR4.PKS</code> (<strong>Intel-only</strong>): Use page protection keys in 64-bit …\n<code>CR0.TS</code>: Set by processor when task was switched but FPU …\n<code>CR4.TSD</code>: Disable access to processor timestamp counter …\n<code>TF</code>: Enable single-step debugging.\n<code>CR4.PKE</code>: Use page protection keys in 64-bit mode to …\n<code>CR4.VME</code>: Enable interrupts and exception handling in …\n<code>VM</code>: Enable virtual real mode.\n<code>VIF</code>: Virtual counterpart to the <code>interrupt_enabled</code> flag, …\n<code>VIP</code>: Indicates an interrupt is pending for VME or PVI.\n<code>CR4.VMX</code> (<strong>Intel-only</strong>): Enable virtual machine extensions.\n<code>CR0.WP</code>: Enforce read-only pages even in privilege levels …\n<code>ZF</code>: Indicates that the result of an instruction is zero.\n<code>SF</code>: Indicates that the most-significant bit of a result is …\n<code>OF</code>: Indicates that the result overflowed for signed …\n<code>CR4.OSXMMEXCPT</code>: Enable unmasked SIMD floating-point …\n<code>XCR0.SSE</code>: Manage SSE state with <code>XSAVE</code>, including the <code>XMM</code> …\n<code>CR4.OSFXSR</code>: Enable the <code>FXSAVE</code>/<code>FXRSTOR</code> and SSE …\n<code>CR4.SMAP</code>: Enable access prevention in privilege levels …\n<code>CR4.SMEP</code>: Enable execution prevention in privilege levels …\n<code>CR4.PKS</code> (<strong>Intel-only</strong>): Use page protection keys in 64-bit …\n<code>CR0.TS</code>: Set by processor when task was switched but FPU …\n<code>CR4.TSD</code>: Disable access to processor timestamp counter …\n<code>TF</code>: Enable single-step debugging.\n<code>CR4.PKE</code>: Use page protection keys in 64-bit mode to …\n<code>CR4.VME</code>: Enable interrupts and exception handling in …\n<code>VM</code>: Enable virtual real mode.\n<code>VIF</code>: Virtual counterpart to the <code>interrupt_enabled</code> flag, …\n<code>VIP</code>: Indicates an interrupt is pending for VME or PVI.\n<code>CR4.VMX</code> (<strong>Intel-only</strong>): Enable virtual machine extensions.\n<code>CR0.AM</code>: Enables strict alignment checks for memory access, …\n<code>AC</code>: Enable strict alignment checks for memory accesses in …\n<code>AF</code>: Indicates a carry/borrow/overflow out of bit 3 in …\n<code>XCR0.AVX</code>: Manage 256-bit AVX state in upper halves of the …\n<code>XCR0.ZMM_Hi256</code>: Manage 512-bit AVX state in the upper …\n<code>XCR0.Hi16_ZMM</code>: Manage AVX-512 state in <code>ZMM16</code>–<code>ZMM31</code> with …\n<code>XCR0.OPMASK</code>: Manage AVX-512 opmask registers with <code>XSAVE</code>.\n<code>CR0.CD</code>: Disable all memory caching.\n<code>CR0.NW</code>: Disable write-back/write-through caching.\n<code>CF</code>: Indicates an arithmetic instruction generated a …\n<code>CR4.CET</code> (<strong>Intel-only</strong>): Enable control-flow enforcement …\n<code>CR4.DE</code>: Enable newer debug register scheme where <code>DR4</code> and …\n<code>DF</code>: String instructions work on addresses high-to-low when …\n<code>CR4.FSGSBASE</code>: Enable instructions to load/store the <code>FS</code> and …\n<code>CR4.OSXSAVE</code>: Enable instructions for saving and restoring …\n<code>CR4.LA57</code>: Support 57-bit addresses using 5-level paging in …\n<code>XCR0.X87</code>: Hardcoded to 1.\n<code>CR0.EM</code>: Trigger an exception on all FPU instructions. Used …\n<code>CR0.ET</code>: On 386/486, 387 FPU instructions are supported if …\n<code>CR4.PGE</code>: Enable global pages, which are shared across task …\n<code>ID</code>: Indicates <code>CPUID</code> support when the flag is modifiable.\n<code>IF</code>: Enable non-maskable interrupts. Non-maskable …\n<code>IOPL</code>: Sets the privilege threshold for a task to access …\n<code>CR4.MCE</code>: Enable machine-check exception.\n<code>CR0.MP</code>: Enable exception behavior described for the <code>CR0.TS</code> …\n<code>XCR0.BNDCSR</code>: Manage MPX config and status registers with …\n<code>XCR0.BNDREG</code>: Manage MPX bounds registers with <code>XSAVE</code>.\n<code>CR0.NE</code>: Use internal error mechanism for FPU errors, …\n<code>NT</code>: Indicates that the processor should switch back to a …\n<code>CR4.PSE</code>: Support large pages (4MB). Applies to 32-bit mode …\n<code>CR0.PG</code>: Enable paging. Requires <code>protected_mode</code>.\n<code>PF</code>: Indicates that the least-significant byte of the …\n<code>CR4.PCE</code>: Allow access to performance monitoring counter in …\n<code>CR4.PAE</code>: Enable pages to map to physical addresses larger …\n<code>CR4.PCIDE</code>: Enable process-context identifiers (PCID) in …\nEnable protected mode. Does not enable paging on its own. …\n<code>CR4.PVI</code>: Enable virtual interrupts in protected mode.\n<code>XCR0.PKRU</code>: Manage protection key rights registers with …\n<code>CR4.UMIP</code>: Prevent access to instructions that allow reads …\n<code>RF</code>: Disable instruction breakpoints.\n<code>CR4.SME</code> (<strong>Intel-only</strong>): Enable safer-mode extensions.\n<code>SF</code>: Indicates that the most-significant bit of a result is …\n<code>OF</code>: Indicates that the result overflowed for signed …\n<code>CR4.OSXMMEXCPT</code>: Enable unmasked SIMD floating-point …\n<code>XCR0.SSE</code>: Manage SSE state with <code>XSAVE</code>, including the <code>XMM</code> …\n<code>CR4.OSFXSR</code>: Enable the <code>FXSAVE</code>/<code>FXRSTOR</code> and SSE …\n<code>CR4.SMAP</code>: Enable access prevention in privilege levels …\n<code>CR4.SMEP</code>: Enable execution prevention in privilege levels …\n<code>CR4.PKS</code> (<strong>Intel-only</strong>): Use page protection keys in 64-bit …\n<code>CR0.TS</code>: Set by processor when task was switched but FPU …\n<code>CR4.TSD</code>: Disable access to processor timestamp counter …\n<code>TF</code>: Enable single-step debugging.\n<code>CR4.PKE</code>: Use page protection keys in 64-bit mode to …\n<code>CR4.VME</code>: Enable interrupts and exception handling in …\n<code>VM</code>: Enable virtual real mode.\n<code>VIF</code>: Virtual counterpart to the <code>interrupt_enabled</code> flag, …\n<code>VIP</code>: Indicates an interrupt is pending for VME or PVI.\n<code>CR4.VMX</code> (<strong>Intel-only</strong>): Enable virtual machine extensions.\n<code>CR0.WP</code>: Enforce read-only pages even in privilege levels …\n<code>ZF</code>: Indicates that the result of an instruction is zero.\n<code>CR0.WP</code>: Enforce read-only pages even in privilege levels …\n<code>ZF</code>: Indicates that the result of an instruction is zero.\nIndicates the processor’s maximum supported physical and …\nPrimary feature list returned in <code>CPUID.01H:ECX+EDX</code>.\nFeatures applicable to 64-bit processors, returned in …\n<code>AESNI</code>: Supports AES acceleration instructions.\n<code>TSC-Deadline</code>: Supports one-shot interrupts with the APIC …\n<code>x2APIC</code>: Supports the enhanced “x2” interface for the …\n<code>AVX</code>: Supports AVX instructions.\nSupports byte swapping with the <code>MOVBE</code> instruction.\n<code>CLFSH</code>: Supports flushing a cache line with the <code>CLFLUSH</code> …\nSupports carry-less multiplication of two 64-bit integers …\nSupports disabling xTPR task priority messages to the …\n<code>CMPXCHG16B</code>: Supports the 128-bit <code>CMPXCHG16B</code> atomic …\n<code>CX8</code>: Supports the 64-byte <code>CMPXCHG8B</code> atomic instruction.\n<code>CMOV</code>: Supports the <code>CMOV</code> instruction and <code>FCMOV</code>/<code>FCOMI</code> if FPU …\nSupports counting the set bits in a value with the <code>POPCNT</code> …\nLow-level CPUID call. Writes the leaf/subleaf index given …\n<code>SDBG</code>: Supports an MSR for chip debugging.\n<code>DS</code>: Supports writing debug information to memory.\n<code>DTES64</code>: Supports 64-bit addresses for the debug store.\n<code>DE</code>: Supports breaking on I/O and on accessing debug …\n<code>EIST</code>: Supports enhanced SpeedStep throttling.\n<code>XSAVE</code>: Supports instructions for saving and restoring …\n<code>OSXSAVE</code>: Reflects the value of […\n<code>F16C</code>: Supports conversion instructions for 16-bit floats.\n<code>FXSAVE</code>: Supports managing FPU state with <code>FXSAVE</code>/<code>FXRSTOR</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>FMA</code>: Supports fused multiply-add SSE instructions.\nRetrieve the feature list from the processor using the …\nRetrieve the extended feature list from the processor …\nRetrieve the supported address space sizes from the …\n<code>PGE</code>: Supports global pages, which are available in all …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>CNXT-ID</code>: Supports setting the L1 cache to adaptive or …\n<code>MCA</code>: Supports extended features for reporting internal …\n<code>MCE</code>: Defines an exception (18) for reporting internal …\n<code>HTT</code>: Indicates that the number of reserved APIC IDs is …\nGet the maximum primary index value (EAX) supported for …\nGet the maximum primary index value (EAX) supported for …\n<code>DCA</code>: Supports prefetching memory-mapped data from a device.\n<code>MTRR</code>: Has memory type range registers.\n<code>MMX</code>: Supports MMX instructions.\n<code>MSR</code>: Has model-specific registers which can be accessed …\n<code>MONITOR</code>: Supports the <code>MONITOR</code>/<code>MWAIT</code> instructions.\n<code>PDCM</code>: Supports a model-specific register that lists …\n<code>APIC</code>: The processor has a built-in advanced programmable …\n<code>FPU</code>: The processor has a built-in x87 floating-point unit\n<code>PAT</code>: Supports page attribute tables.\n<code>PSE</code>: Supports 4MB virtual memory pages and the dirty flag.\n<code>PSE-36</code>: Supports 4MB virtual memory pages that can map to …\n<code>PBE</code>: Supports a pin notifying a stopped processor that an …\n<code>DS-CPL</code>: Supports saving the permission level with data …\n<code>PAE</code>: Supports mapping virtual memory to physical addresses …\n<code>PCID</code>: Supports process-context IDs.\nSupports random number generation with the <code>RDRAND</code> …\n<code>SMX</code>: Supports safer-mode extensions\nThe processor can snoop on its own cache line. This helps …\n<code>PSN</code>: Supports retrieving a processor serial number with …\n<code>AESNI</code>: Supports AES acceleration instructions.\n<code>TSC-Deadline</code>: Supports one-shot interrupts with the APIC …\n<code>x2APIC</code>: Supports the enhanced “x2” interface for the …\n<code>AVX</code>: Supports AVX instructions.\nSupports byte swapping with the <code>MOVBE</code> instruction.\n<code>CLFSH</code>: Supports flushing a cache line with the <code>CLFLUSH</code> …\nSupports carry-less multiplication of two 64-bit integers …\nSupports disabling xTPR task priority messages to the …\n<code>CMPXCHG16B</code>: Supports the 128-bit <code>CMPXCHG16B</code> atomic …\n<code>CX8</code>: Supports the 64-byte <code>CMPXCHG8B</code> atomic instruction.\n<code>CMOV</code>: Supports the <code>CMOV</code> instruction and <code>FCMOV</code>/<code>FCOMI</code> if FPU …\nSupports counting the set bits in a value with the <code>POPCNT</code> …\n<code>SDBG</code>: Supports an MSR for chip debugging.\n<code>DS</code>: Supports writing debug information to memory.\n<code>DTES64</code>: Supports 64-bit addresses for the debug store.\n<code>DE</code>: Supports breaking on I/O and on accessing debug …\n<code>EIST</code>: Supports enhanced SpeedStep throttling.\n<code>XSAVE</code>: Supports instructions for saving and restoring …\n<code>OSXSAVE</code>: Reflects the value of […\n<code>F16C</code>: Supports conversion instructions for 16-bit floats.\n<code>FXSAVE</code>: Supports managing FPU state with <code>FXSAVE</code>/<code>FXRSTOR</code>.\n<code>FMA</code>: Supports fused multiply-add SSE instructions.\n<code>PGE</code>: Supports global pages, which are available in all …\n<code>CNXT-ID</code>: Supports setting the L1 cache to adaptive or …\n<code>MCA</code>: Supports extended features for reporting internal …\n<code>MCE</code>: Defines an exception (18) for reporting internal …\n<code>HTT</code>: Indicates that the number of reserved APIC IDs is …\n<code>DCA</code>: Supports prefetching memory-mapped data from a device.\n<code>MTRR</code>: Has memory type range registers.\n<code>MMX</code>: Supports MMX instructions.\n<code>MSR</code>: Has model-specific registers which can be accessed …\n<code>MONITOR</code>: Supports the <code>MONITOR</code>/<code>MWAIT</code> instructions.\n<code>PDCM</code>: Supports a model-specific register that lists …\n<code>APIC</code>: The processor has a built-in advanced programmable …\n<code>FPU</code>: The processor has a built-in x87 floating-point unit\n<code>PAT</code>: Supports page attribute tables.\n<code>PSE</code>: Supports 4MB virtual memory pages and the dirty flag.\n<code>PSE-36</code>: Supports 4MB virtual memory pages that can map to …\n<code>PBE</code>: Supports a pin notifying a stopped processor that an …\n<code>DS-CPL</code>: Supports saving the permission level with data …\n<code>PAE</code>: Supports mapping virtual memory to physical addresses …\n<code>PCID</code>: Supports process-context IDs.\nSupports random number generation with the <code>RDRAND</code> …\n<code>SMX</code>: Supports safer-mode extensions\nThe processor can snoop on its own cache line. This helps …\n<code>PSN</code>: Supports retrieving a processor serial number with …\n<code>SSE</code>: Supports SSE instructions.\n<code>SSE2</code>: Supports SSE2 instructions.\n<code>SSE3</code>: Supports SSE3 instructions.\n<code>SSE4_1</code>: Supports SSE4.1 instructions.\n<code>SSE4_2</code>: Supports SSE4.2 instructions.\n<code>SSSE3</code>: Supports Supplemental SSE3 (SSSE3) instructions.\n<code>SEP</code>: Supports the <code>SYSENTER</code>/<code>SYSEXIT</code> instructions.\n<code>TM</code>: Has thermal monitor control circuitry (TCC).\nSupports the TM2 thermal monitor interface.\n<code>ACPI</code>: Supports thermal monitoring and power management …\n<code>TSC</code>: Supports reading the processor’s timestamp with …\n<code>VME</code>: Supports virtual real-mode extensions (VME) and …\n<code>VMX</code>: Supports virtual machine extensions.\n<code>SSE</code>: Supports SSE instructions.\n<code>SSE2</code>: Supports SSE2 instructions.\n<code>SSE3</code>: Supports SSE3 instructions.\n<code>SSE4_1</code>: Supports SSE4.1 instructions.\n<code>SSE4_2</code>: Supports SSE4.2 instructions.\n<code>SSSE3</code>: Supports Supplemental SSE3 (SSSE3) instructions.\n<code>SEP</code>: Supports the <code>SYSENTER</code>/<code>SYSEXIT</code> instructions.\n<code>TM</code>: Has thermal monitor control circuitry (TCC).\nSupports the TM2 thermal monitor interface.\n<code>ACPI</code>: Supports thermal monitoring and power management …\n<code>TSC</code>: Supports reading the processor’s timestamp with …\n<code>VME</code>: Supports virtual real-mode extensions (VME) and …\n<code>VMX</code>: Supports virtual machine extensions.\n<code>AESNI</code>: Supports AES acceleration instructions.\n<code>TSC-Deadline</code>: Supports one-shot interrupts with the APIC …\n<code>x2APIC</code>: Supports the enhanced “x2” interface for the …\n<code>AVX</code>: Supports AVX instructions.\nSupports byte swapping with the <code>MOVBE</code> instruction.\n<code>CLFSH</code>: Supports flushing a cache line with the <code>CLFLUSH</code> …\nSupports carry-less multiplication of two 64-bit integers …\nSupports disabling xTPR task priority messages to the …\n<code>CMPXCHG16B</code>: Supports the 128-bit <code>CMPXCHG16B</code> atomic …\n<code>CX8</code>: Supports the 64-byte <code>CMPXCHG8B</code> atomic instruction.\n<code>CMOV</code>: Supports the <code>CMOV</code> instruction and <code>FCMOV</code>/<code>FCOMI</code> if FPU …\nSupports counting the set bits in a value with the <code>POPCNT</code> …\n<code>SDBG</code>: Supports an MSR for chip debugging.\n<code>DS</code>: Supports writing debug information to memory.\n<code>DTES64</code>: Supports 64-bit addresses for the debug store.\n<code>DE</code>: Supports breaking on I/O and on accessing debug …\n<code>EIST</code>: Supports enhanced SpeedStep throttling.\n<code>XSAVE</code>: Supports instructions for saving and restoring …\n<code>OSXSAVE</code>: Reflects the value of […\n<code>F16C</code>: Supports conversion instructions for 16-bit floats.\n<code>FXSAVE</code>: Supports managing FPU state with <code>FXSAVE</code>/<code>FXRSTOR</code>.\n<code>FMA</code>: Supports fused multiply-add SSE instructions.\n<code>PGE</code>: Supports global pages, which are available in all …\n<code>CNXT-ID</code>: Supports setting the L1 cache to adaptive or …\n<code>MCA</code>: Supports extended features for reporting internal …\n<code>MCE</code>: Defines an exception (18) for reporting internal …\n<code>HTT</code>: Indicates that the number of reserved APIC IDs is …\n<code>DCA</code>: Supports prefetching memory-mapped data from a device.\n<code>MTRR</code>: Has memory type range registers.\n<code>MMX</code>: Supports MMX instructions.\n<code>MSR</code>: Has model-specific registers which can be accessed …\n<code>MONITOR</code>: Supports the <code>MONITOR</code>/<code>MWAIT</code> instructions.\n<code>PDCM</code>: Supports a model-specific register that lists …\n<code>APIC</code>: The processor has a built-in advanced programmable …\n<code>FPU</code>: The processor has a built-in x87 floating-point unit\n<code>PAT</code>: Supports page attribute tables.\n<code>PSE</code>: Supports 4MB virtual memory pages and the dirty flag.\n<code>PSE-36</code>: Supports 4MB virtual memory pages that can map to …\n<code>PBE</code>: Supports a pin notifying a stopped processor that an …\n<code>DS-CPL</code>: Supports saving the permission level with data …\n<code>PAE</code>: Supports mapping virtual memory to physical addresses …\n<code>PCID</code>: Supports process-context IDs.\nSupports random number generation with the <code>RDRAND</code> …\n<code>SMX</code>: Supports safer-mode extensions\nThe processor can snoop on its own cache line. This helps …\n<code>PSN</code>: Supports retrieving a processor serial number with …\n<code>SSE</code>: Supports SSE instructions.\n<code>SSE2</code>: Supports SSE2 instructions.\n<code>SSE3</code>: Supports SSE3 instructions.\n<code>SSE4_1</code>: Supports SSE4.1 instructions.\n<code>SSE4_2</code>: Supports SSE4.2 instructions.\n<code>SSSE3</code>: Supports Supplemental SSE3 (SSSE3) instructions.\n<code>SEP</code>: Supports the <code>SYSENTER</code>/<code>SYSEXIT</code> instructions.\n<code>TM</code>: Has thermal monitor control circuitry (TCC).\nSupports the TM2 thermal monitor interface.\n<code>ACPI</code>: Supports thermal monitoring and power management …\n<code>TSC</code>: Supports reading the processor’s timestamp with …\n<code>VME</code>: Supports virtual real-mode extensions (VME) and …\n<code>VMX</code>: Supports virtual machine extensions.\n<code>IA32_APIC_BASE</code>: A model-specific register that allows …\n<code>#AC</code>: Improperly aligned memory access in user mode while …\n<code>#BR</code>: Out-of-bounds index detected with <code>BOUND</code> instruction.\n<code>#BP</code>: Breakpoint via <code>INT3</code> instruction.\n<code>#CP</code>: Improper branching detected by control-flow guard.\nThe default APIC base address when the processor is reset.\n<code>#DB</code>: Breakpoints or other debugging-related traps/faults.\n<code>#NM</code>: Tried to execute FPU instruction with no coprocessor …\n<code>#DE</code>: Division by zero or overflow in division.\n<code>#DF</code>: A fault was triggered while handling another …\n<code>#MF</code>: Unmasked floating-point error that was <em>not</em> part of a …\n<code>IDTR</code>: Contains the memory range of the interrupt …\nAn interrupt/exception number.\n<code>#UD</code>: Unrecognized or reserved instruction opcode.\n<code>#TS</code>: An error was found in the TSS while task switching.\n<code>#MC</code>: Internal processor/bus error.\n<code>NMI</code>: Severe external interrupt that cannot be ignored.\n<code>#OF</code>: Overflow condition was detected with <code>INTO</code> instruction.\n<code>#PF</code>: Tried to load a page that was not present, or used a …\n<code>#GP</code>: Memory protection or other miscellaneous error.\n<code>#XM</code>: Unmasked floating-point error during SIMD operation.\n<code>#NP</code>: Tried to use a segment without a descriptor defined. …\n<code>#SS</code>: The stack overflowed its segment or the segment was …\n<code>#VE</code>: Improper use of virtualization extensions.\nBase address of the APIC’s registers.\nBase address of the descriptor table.\nIndicates that this core was designated as the bootstrap …\nCan be cleared to disable the APIC. However, it cannot be …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRetrieve the current value of this register\nRetrieve the current value of this register\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe inclusive maximum address offset (i.e., size - 1) of …\nThe name of the enum variant in code, if one is defined …\nIndicates that this is interrupt vector is reserved by the …\nUpdate the register to the given value.\nUpdate the register to the given value.\nUpdate the base address of the APIC’s registers.\nIndicates that this core was designated as the bootstrap …\nCan be cleared to disable the APIC. However, it cannot be …\nEnable the APIC’s\nIndicates that this core was designated as the bootstrap …\nCan be cleared to disable the APIC. However, it cannot be …\nEnable the APIC’s\nEnable the APIC’s\nRead a 16-bit value from the port at the given address in …\nRead a 32-bit value from the port at the given address in …\nRead an 8-bit value from the port at the given address in …\nWrite a 16-bit value to the port at the given address in …\nWrite a 16-bit value to the port at the given address in …\nWrite an 8-bit value to the port at the given address in …\n<code>CR2</code>: Contains the address that triggered a page fault.\n<code>CR3</code>: System control register that contains the top-level …\nAn page table entry (any level) that directly maps a page.\nAn entry in a page table at any level.\nA page table entry (any level) that either directly maps a …\nBottom-level page table entry that maps a single 4KB page.\nSecond-level page table (page directory) entry that either …\n<code>A</code>: Set by the processor when an instruction accesses the …\nGet the address of the top-level page table.\n<code>PAT</code>: Used to associate this page with a page attribute …\n<code>PCD</code>: Disables caching for this memory region.\n<code>CR3.PCD</code>: Disables caching for the top-level page table.\n<code>D</code>: Set by the processor when an instruction modifies the …\nPrint this object’s bitfield values. Helper method for …\nPrint this object’s bitfield values. Helper method for …\nPrint this object’s bitfield values. Helper method for …\nPrint this object’s bitfield values. Helper method for …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRetrieve the current value of this register\nRetrieve the current value of this register\n<code>G</code>: Indicates that this is a global page shared by all task …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>PS</code>: Indicates that this entry directly maps a page. …\n<code>XD</code>/<code>NX</code>: Prevent the processor from executing any …\n<code>P</code>: Indicates that this entry is mapped. Otherwise the …\n<code>CR4.PCIDE</code>: The process-context identifier (PCID) …\nThe protection key that applies to this memory region.\nUpdate the register to the given value.\nUpdate the register to the given value.\n<code>A</code>: Set by the processor when an instruction accesses the …\nSet the address of the top-level page table.\n<code>PAT</code>: Used to associate this page with a page attribute …\n<code>PCD</code>: Disables caching for this memory region.\n<code>CR3.PCD</code>: Disables caching for the top-level page table.\n<code>D</code>: Set by the processor when an instruction modifies the …\n<code>G</code>: Indicates that this is a global page shared by all task …\n<code>PS</code>: Indicates that this entry directly maps a page. …\n<code>XD</code>/<code>NX</code>: Prevent the processor from executing any …\n<code>P</code>: Indicates that this entry is mapped. Otherwise the …\n<code>CR4.PCIDE</code>: The process-context identifier (PCID) …\nThe protection key that applies to this memory region.\n<code>U/S</code>: Allows access to this memory region from permission …\n<code>R/W</code>: Allows writes to this memory region.\n<code>PWT</code>: Enables write-through caching for this memory region.\n<code>CR3.PWT</code>: Enables write-through caching for the top-level …\n<code>U/S</code>: Allows access to this memory region from permission …\n<code>A</code>: Set by the processor when an instruction accesses the …\n<code>PAT</code>: Used to associate this page with a page attribute …\n<code>PCD</code>: Disables caching for this memory region.\n<code>CR3.PCD</code>: Disables caching for the top-level page table.\n<code>D</code>: Set by the processor when an instruction modifies the …\n<code>G</code>: Indicates that this is a global page shared by all task …\n<code>PS</code>: Indicates that this entry directly maps a page. …\n<code>XD</code>/<code>NX</code>: Prevent the processor from executing any …\n<code>P</code>: Indicates that this entry is mapped. Otherwise the …\n<code>CR4.PCIDE</code>: The process-context identifier (PCID) …\nThe protection key that applies to this memory region.\n<code>U/S</code>: Allows access to this memory region from permission …\n<code>R/W</code>: Allows writes to this memory region.\n<code>PWT</code>: Enables write-through caching for this memory region.\n<code>CR3.PWT</code>: Enables write-through caching for the top-level …\n<code>R/W</code>: Allows writes to this memory region.\n<code>PWT</code>: Enables write-through caching for this memory region.\n<code>CR3.PWT</code>: Enables write-through caching for the top-level …\nA <code>GateDescriptor</code> for a call to 32/64-bit code.\nA <code>GateDescriptor</code> for a call to 16-bit code.\n<code>CS</code> register, which controls instruction loading\n<code>DS</code> register, which controls the default segment for …\nSettings common to <code>SegmentDescriptor</code>s and <code>GateDescriptor</code>s.\n<code>ES</code> segment register, which can be used as an additional …\n<code>FS</code> segment register, which can be used as an additional …\n<code>GS</code> segment register, which can be used as an additional …\nAn entry in a segment descriptor table that points to an …\nSettings for <code>GateDescriptor</code>s.\nGeneric entry in a global/local/interrupt descriptor …\nSettings for <code>GenericDescriptor</code>s.\n<code>GDTR</code>: Points to the memory range of the global descriptor …\nBitmap that controls which I/O port addresses are covered …\nA <code>GateDescriptor</code> for a 32/64-bit interrupt handler.\nA <code>GateDescriptor</code> for a 16-bit interrupt handler.\nThe maximum supported value of the <code>limit</code> field (20 bits).\nA <code>SegmentDescriptor</code> for a segment that contains a local …\n<code>LDTR</code>: Contains a <code>Selector</code> referencing a <code>SegmentDescriptor</code> …\nSize in bytes required to map all I/O ports\nAn entry in a segment descriptor table that defines a new …\nSettings for <code>SegmentDescriptor</code>s.\nStandard segment registers (<code>CS</code>, <code>DS</code>, <code>SS</code>, etc.), which …\nA reference to an entry in a segment descriptor table.\n<code>SS</code> segment register, which controls the location of the …\nDiscriminate types of segment descriptors that are not …\nA <code>GateDescriptor</code> for task switching.\n<code>TR</code>: Contains a <code>Selector</code> referencing a <code>SegmentDescriptor</code> …\nA <code>SegmentDescriptor</code> for a 32/64-bit task state segment …\nA <code>SegmentDescriptor</code> for a 16-bit task state segment (TSS) …\nA <code>SegmentDescriptor</code> for a 32/64-bit task state segment …\nA <code>SegmentDescriptor</code> for a 16-bit task state segment (TSS) …\nA <code>GateDescriptor</code> for a 32/64-bit interrupt handler.\nA <code>GateDescriptor</code> for a 16-bit trap handler.\nBase virtual address of the segment, to which offsets are …\nBase address of the descriptor table\nThe processor sets this bit whenever a segment register …\n<code>D</code>/<code>B</code>: Indicates that the segment uses 32-bit mode. …\nNumber of stack parameters to copy if the code segment …\nIf this is a code descriptor, indicates that this segment …\n<code>L</code>: If this is a code segment, indicates that it should be …\nIf this is a code descriptor, indicates that the segment …\nGet a pointer to the <code>SegmentDescriptor</code> for the …\nIf this is a data descriptor, indicates that the segment …\nIf this is a data descriptor, indicates that this segment …\nCalculate the address of the descriptor referenced by this …\nOffset of the entry point in code segment referenced by …\nCommon descriptor settings.\nCommon segment descriptor settings.\nCommon gate descriptor settings.\nPrint this object’s bitfield values. Helper method for …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRetrieve the current value of this register\nRetrieve the current value of this register\nRetrieve the current value of this register\nRetrieve the current value of this register\n<code>G</code>: Indicates that the segment limit is in units of 4KB. …\nOne-based index of the <code>interrupt_stack</code> pointer to use when …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>S</code>: Indicates that this is an application section …\nIndicates whether this is a code (true) or data (false) …\nIndicates that this is a <code>GateDescriptor</code>.\nIndicates that this is a <code>GateDescriptor</code>.\nGet the value in this bitmap that indicates whether the …\nThe “limit” of the segment, which is a maximum or …\nThe inclusive maximum address offset (i.e., size - 1) of …\nIndicates that this selector references a descriptor in …\nThe last I/O port that is covered by this map. The bits …\nCalculate the last I/O port that is covered by a map of …\nThe name of the enum variant in code, if one is defined …\nCreate a new selector with the given field values\nCreate a zero-initialized descriptor\nCreate a zero-initialized descriptor\nCreate a null selector\nThe offset of the referenced segment entry in the …\n<code>AVL</code>: Ignored bit that can be used by the operating system.\n<code>P</code>: Indicates that the segment is defined.\n<code>DPL</code>: The privilege level associated with the segment.\n<code>RPL</code>: The privilege level “requested” when accessing …\nCalculate the size in bytes of a map that has bits for …\nSelector that points to the code or task state segment to …\nUpdate the register with the value in this struct.\nUpdate the register with the provided selector value.\nUpdate the register with the provided selector value.\nUpdate the register to the given value.\nUpdate the base address.\nThe processor sets this bit whenever a segment register …\n<code>D</code>/<code>B</code>: Indicates that the segment uses 32-bit mode. …\nNumber of stack parameters to copy if the code segment …\nIf this is a code descriptor, indicates that this segment …\n<code>L</code>: If this is a code segment, indicates that it should be …\nIf this is a code descriptor, indicates that the segment …\nIf this is a data descriptor, indicates that the segment …\nIf this is a data descriptor, indicates that this segment …\nUpdate the offset of the entry point within the referenced …\n<code>G</code>: Indicates that the segment limit is in units of 4KB. …\nOne-based index of the <code>interrupt_stack</code> pointer to use when …\n<code>S</code>: Indicates that this is an application section …\nIndicates whether this is a code (true) or data (false) …\nUpdate the segment limit.\nIndicates that this selector references a descriptor in …\nUpdate the offset of the referenced entry in the …\n<code>AVL</code>: Ignored bit that can be used by the operating system.\nSet the value in this bitmap that indicates whether the …\n<code>P</code>: Indicates that the segment is defined.\n<code>DPL</code>: The privilege level associated with the segment.\n<code>RPL</code>: The privilege level “requested” when accessing …\nUpdate the selector pointing to the segment to be accessed …\nIf this is a system descriptor, indicates which type.\nUpdate the global descriptor table pointer and all segment …\nThe number of bytes in this structure.\nIf this is a system descriptor, indicates which type.\nThe processor sets this bit whenever a segment register …\n<code>D</code>/<code>B</code>: Indicates that the segment uses 32-bit mode. …\nNumber of stack parameters to copy if the code segment …\nIf this is a code descriptor, indicates that this segment …\n<code>L</code>: If this is a code segment, indicates that it should be …\nIf this is a code descriptor, indicates that the segment …\nIf this is a data descriptor, indicates that the segment …\nIf this is a data descriptor, indicates that this segment …\n<code>G</code>: Indicates that the segment limit is in units of 4KB. …\nOne-based index of the <code>interrupt_stack</code> pointer to use when …\n<code>S</code>: Indicates that this is an application section …\nIndicates whether this is a code (true) or data (false) …\nIndicates that this selector references a descriptor in …\n<code>AVL</code>: Ignored bit that can be used by the operating system.\n<code>P</code>: Indicates that the segment is defined.\n<code>DPL</code>: The privilege level associated with the segment.\n<code>RPL</code>: The privilege level “requested” when accessing …\nIf this is a system descriptor, indicates which type.")